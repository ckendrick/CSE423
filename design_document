Team Members: Coleman Kendrick, Eva Domschott, Nathan Bockisch, Brandon Bicknell

Program Overview

To compile program:
mkdir build
cd build
cmake ..
make

Most likely needs to be updated to allow for Bison

To use the program, run ./scanner -f <file>

Additional flags include:
-i: Print tokens
-a: Print AST

The tokenizer separates punctuation characters like braces, colons, semicolons, and commas. It also supports multi-character operators like ++ and !=. It recognizes all of the C keywords and separates them and categorizes them before storing them into a vector. 

Usage

Design Discussion

Scanner:
The tokenizer is yylex, the GNU lexicon analyzer, so that the input can be appropriately passed through to the parser.
yylex requires a matching of symbols to codes, so when a symbol is seen in the input stream, it returns the appropriate code.
For string symbols, alias are used in place of the string.

Parser:
The parser is implemented using GNU Bison 3.0.4. The C- grammer is encoded into an xml format that Bison accepts, which is then automatically parsed through the library, which will be passed along for creating the Symbol Table and Abstract Syntax Tree.

Abstract Syntax Tree:
The AST is a binary tree. Insertion is done by taking in a vector of the tokens in a top down order. So far only a basic program can be inserted. Waiting on the parser for some of the details. Since the parser isn't finished, an array of strings in top down order is being passed to it to show insertion. 

Symbol Table:
To Be Completed

Language Specification

Implements the below grammar:
$accept → program $end #Parser Rule
program → declist
declist → declaration | declist declaration
declaration → var_decl | func_decl | expr | RETURN expr ; | if_decl | WHILE expr block
block → { declist } | { }
if_decl → IF expr block else_decl | IF expr block
else_decl → ELSE block
var_decl → type ident | type ident = expr ;
func_decl → type ident ( func_decl_args ) block
func_decl_args → EPSILON | var_decl | func_decl_args , var_decl
ident → IDENTIFIER
type → INT | VOID
number → INTEGER | DOUBLE
expr → ident = expr ; | ident ( call_args ) ; | ident | number | expr * expr | expr / expr | expr + expr | expr - expr | expr compare expr | ( expr )
call_args → EPSILON | expr | call_args , expr
compare → == | != | < | <= | > | >=


